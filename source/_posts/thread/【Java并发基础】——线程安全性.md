---
title: 【Java并发基础】——线程安全性
categories:
  - Java
     - 多线程
        - 并发基础
tags:
  - 多线程
---



要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是<u>对共享的和可变的状态</u>的访问。

一个对象是否需要是线程安全的，取决于它是否被多个线程访问。要使得对象是线程安全的，需要采用同步机制来协同对对象可变状态的访问。

<!-- more -->

> 如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
>
> - 不在线程之间共享该状态变量
> - 将状态变量修改为不可变的变量
> - 在访问状态变量时使用同步

在线程安全性的定义中，最核心的概念就是正确性。如果对线程安全性的定义是模糊的，那么就是因为缺乏对准确性的清晰定义。

*正确性的含义是，某个类的行为与其规范完全一致。*在良好的规范中通常会定义各种<u>*不变性条件*</u>来约束对象的状态，以及定义各种后验条件来描述对象操作的结果。

> *线程安全类*：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

### **内存模型** ###

多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：<u>可见性和有序性</u>。加上<u>复合操作的原子性</u>，我们可以认为Java的线程安全问题主要关注点有3个：

1. 可见性
2. 有序性
3. 原子性

在理解这三大特性之前，有必要先了解“内存模型”的相关概念。

　　计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。

　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：

```
i = i + 1;
```

 　　当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。

　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。

　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？

　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。

　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。

　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。

##### 可见性 #####

从上面的描述可知，在多线程环境下会存在可见性的问题。Java内存模型（JMM）提供了一些机制来解决这些问题。例如`Volatile`关键字。

*可见性指的是一个线程对变量的写操作对其它线程后续的读操作可见。*

##### 原子性 #####

> **多线程中关于“原子性”的定义：**
>
> 如果这个操作所处的层(layer)的更高层不能发现其内部实现与结构，那么这个操作是一个原子(atomic)操作。
>
> 将整个操作视作一个整体是原子性的核心特征。
>
> 原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分。
>
> 原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。
>

有时候我们希望某个操作以原子的方式执行，否则在多线程环境下会出现问题如程序清单2-2中的`UnSafeCountingFactorizer`所示，我们希望增加一个“命中计数器”来统计所处理的请求数量。虽然递增操作`++count`是一种紧凑的语法，使其看上去只是一个操作，但这个操作并非原子的，因而它并不会作为一个不可分割的操作来执行。这是一个“读取-修改-写入”的操作序列，并且其结果状态依赖于之前的状态。

###### 程序清单2-2 在没有同步的情况下统计已处理请求数量的Servlet（不要这么做） ######

```java
@NotThreadSafe
public class UnSafeCountingFactorizer implements Servlet {
    
    private long count = 0;

    public long getCount() {
        return count;
    }
    
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        ++count; //这里包含了3个独立的操作：读取count的值，将值加1，将计算结果写入count
        encodeIntoResponse(resp, factors);
    }
    
}
```

通常以下情况需要保证原子性：结果状态依赖之前的状态、不变性条件包含多个变量、存在竞态条件。

> 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

##### 竞态条件 #####

当某个计算的正确性取决于多个线程的交替执行时序，那么就会发生*竞态条件*。

最常见的竞态条件类型就是“先检查后执行”操作，即通过一个可能失效的观测结果来决定下一步的动作：首先观察到某个条件为真（例如文件X不存在），然后根据这个观察结果采用相应的动作（创建文件X），但事实上，在你观察到这个结果以及开始创建文件之间，观察结果可能变得无效（另一个线程在这期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。

##### 复合操作 #####

我们将“先检查后执行”以及“读取-修改-写入”等操作统一称为*复合操作*：包含了一组必须以原子方式执行的操作以确保线程安全性。

