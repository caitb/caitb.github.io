<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="CAI TB,undefined"><meta name="copyright" content="CAI TB"><title>CAITBのBlog</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="/css/vue.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="sidebar" id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-nav sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#谈谈高并发下的幂等性处理"><span class="toc-number">1.</span> <span class="toc-text">谈谈高并发下的幂等性处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是幂等性"><span class="toc-number">2.</span> <span class="toc-text">什么是幂等性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么需要幂等"><span class="toc-number">3.</span> <span class="toc-text">为什么需要幂等</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么情况下需要保证幂等性"><span class="toc-number">4.</span> <span class="toc-text">什么情况下需要保证幂等性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#保证幂等策略"><span class="toc-number">5.</span> <span class="toc-text">保证幂等策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#防重复提交策略"><span class="toc-number">6.</span> <span class="toc-text">防重复提交策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#乐观锁"><span class="toc-number">6.1.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#防重表"><span class="toc-number">6.2.</span> <span class="toc-text">防重表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式锁"><span class="toc-number">6.3.</span> <span class="toc-text">分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#token令牌"><span class="toc-number">6.4.</span> <span class="toc-text">token令牌</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#支付缓冲区"><span class="toc-number">6.5.</span> <span class="toc-text">支付缓冲区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#幂等性接口的不足"><span class="toc-number">7.</span> <span class="toc-text">幂等性接口的不足</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvak7x33btj30500500ui.jpg"></div><div class="author-info__name text-center">CAI TB</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">27</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><div class="content" id="content-outer"><div id="top-container" style="background-image: url(https://ws1.sinaimg.cn/large/006tNbRwgy1fvak4ulv7nj31hc0xc0yl.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">CAITBのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">无题</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-13</time></div></div></div><div class="layout" id="content-inner"><article class="markdown-section" id="post"><div class="article-container" id="post-content"><h1 id="谈谈高并发下的幂等性处理"><a href="#谈谈高并发下的幂等性处理" class="headerlink" title="谈谈高并发下的幂等性处理"></a>谈谈高并发下的幂等性处理</h1><blockquote>
<p>转载地址：<a href="https://blog.csdn.net/aly1989/article/details/52352726" target="_blank" rel="noopener">https://blog.csdn.net/aly1989/article/details/52352726</a></p>
</blockquote>
<h1 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h1><p>HTTP/1.1中对幂等性的定义是：</p>
<blockquote>
<p>Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</p>
</blockquote>
<p>这里不讨论学术上如何定义幂等性，而是重点在于如何在分布式环境中提供对外幂等性的接口。对外提供的接口承诺幂等性，其要表达的含义是：只要调用接口成功，外部对接口的多次调用得到的结果是相同的。即执行多次和一次的效果是一样的。</p>
<h1 id="为什么需要幂等"><a href="#为什么需要幂等" class="headerlink" title="为什么需要幂等"></a>为什么需要幂等</h1><p>上面小明遇到的问题，就是在防止重复提交的情况上没有做好控制。业务开发中，经常会遇到重复提交的情况，无论是由于网络问题无法收到请求结果而重新发起请求，或是前端的操作抖动而造成重复提交情况。 在交易系统，支付系统这种重复提交造成的问题有尤其明显，比如：</p>
<ul>
<li>用户在APP上连续点击了多次提交订单，后台应该只产生一个订单。（下多个相同的单，我有病啊）</li>
<li>向支付宝发起支付请求，由于网络问题或系统BUG重发，支付宝应该只扣一次钱。（多付N笔钱，我真有钱啊）</li>
<li>很显然，幂等接口认为，外部调用者会存在多次调用的场景，为了防止重试对数据状态的改变，需要将接口的设计为幂等的。</li>
</ul>
<h1 id="什么情况下需要保证幂等性"><a href="#什么情况下需要保证幂等性" class="headerlink" title="什么情况下需要保证幂等性"></a>什么情况下需要保证幂等性</h1><p>以SQL为例，有下面三种场景，只有第三种场景需要开发人员使用其他策略保证幂等性：</p>
<ol>
<li><code>SELECT col1 FROM tab1 WHER col2=2</code>，无论执行多少次都不会改变状态，是天然的幂等。</li>
<li><code>UPDATE tab1 SET col1=1 WHERE col2=2</code>，无论执行成功多少次状态都是一致的，因此也是幂等操作。</li>
<li><code>UPDATE tab1 SET col1=col1+1 WHERE col2=2</code>，每次执行的结果都会发生变化，这种不是幂等的。</li>
</ol>
<h1 id="保证幂等策略"><a href="#保证幂等策略" class="headerlink" title="保证幂等策略"></a>保证幂等策略</h1><p>幂等需要通过唯一的业务单号来保证。也就是说相同的业务单号，认为是同一笔业务。使用这个唯一的业务单号来确保，后面多次的相同的业务单号的处理逻辑和执行效果是一致的。 下面以支付为例，在不考虑并发的情况下，实现幂等很简单：①先查询一下订单是否已经支付过，②如果已经支付过，则返回支付成功；如果没有支付，进行支付流程，修改订单状态为‘已支付’。</p>
<h1 id="防重复提交策略"><a href="#防重复提交策略" class="headerlink" title="防重复提交策略"></a>防重复提交策略</h1><p>上述的保证幂等方案是分成两步的，第②步依赖第①步的查询结果，无法保证原子性的。在高并发下就会出现下面的情况：第二次请求在第一次请求第②步订单状态还没有修改为‘已支付状态’的情况下到来。既然得出了这个结论，余下的问题也就变得简单：把查询和变更状态操作加锁，将并行操作改为串行操作。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>如果只是更新已有的数据，没有必要对业务进行加锁，设计表结构时使用乐观锁，一般通过version来做乐观锁，这样既能保证执行效率，又能保证幂等。例如： <code>UPDATE tab1 SET col1=1,version=version+1 WHERE version=#version#</code> 不过，乐观锁存在失效的情况，就是常说的ABA问题，不过如果version版本一直是自增的就不会出现ABA的情况。 </p>
<h2 id="防重表"><a href="#防重表" class="headerlink" title="防重表"></a>防重表</h2><p>使用订单号orderNo做为去重表的唯一索引，每次请求都根据订单号向去重表中插入一条数据。第一次请求查询订单支付状态，当然订单没有支付，进行支付操作，无论成功与否，执行完后更新订单状态为成功或失败，删除去重表中的数据。后续的订单因为表中唯一索引而插入失败，则返回操作失败，直到第一次的请求完成（成功或失败）。可以看出防重表作用是加锁的功能。 </p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>这里使用的防重表可以使用分布式锁代替，比如Redis。订单发起支付请求，支付系统会去Redis缓存中查询是否存在该订单号的Key，如果不存在，则向Redis增加Key为订单号。查询订单支付已经支付，如果没有则进行支付，支付完成后删除该订单号的Key。通过Redis做到了分布式锁，只有这次订单订单支付请求完成，下次请求才能进来。相比去重表，将放并发做到了缓存中，较为高效。思路相同，同一时间只能完成一次支付请求。 </p>
<h2 id="token令牌"><a href="#token令牌" class="headerlink" title="token令牌"></a>token令牌</h2><p>这种方式分成两个阶段：申请token阶段和支付阶段。 第一阶段，在进入到提交订单页面之前，需要订单系统根据用户信息向支付系统发起一次申请token的请求，支付系统将token保存到Redis缓存中，为第二阶段支付使用。 第二阶段，订单系统拿着申请到的token发起支付请求，支付系统会检查Redis中是否存在该token，如果存在，表示第一次发起支付请求，删除缓存中token后开始支付逻辑处理；如果缓存中不存在，表示非法请求。 实际上这里的token是一个信物，支付系统根据token确认，你是你妈的孩子。不足是需要系统间交互两次，流程较上述方法复杂。 </p>
<h2 id="支付缓冲区"><a href="#支付缓冲区" class="headerlink" title="支付缓冲区"></a>支付缓冲区</h2><p>把订单的支付请求都快速地接下来，一个快速接单的缓冲管道。后续使用异步任务处理管道中的数据，过滤掉重复的待支付订单。 优点是同步转异步，高吞吐。不足是不能及时地返回支付结果，需要后续监听支付结果的异步返回。</p>
<h1 id="幂等性接口的不足"><a href="#幂等性接口的不足" class="headerlink" title="幂等性接口的不足"></a>幂等性接口的不足</h1><ul>
<li>增加了额外控制幂等的业务逻辑，复杂化了业务功能；</li>
<li>把并行执行的功能改为串行执行，降低了执行效率。</li>
<li>因此除了业务上的特殊要求外，尽量不提供幂等的接口。</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CAI TB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://caitb.github.io/2018/08/13/thread/谈谈高并发下的幂等性处理/">https://caitb.github.io/2018/08/13/thread/谈谈高并发下的幂等性处理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://caitb.github.io" target="_blank">CAITBのBlog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/08/13/thread/【Java并发基础】——线程安全性/"><i class="fa fa-chevron-left">  </i><span>【Java并发基础】——线程安全性</span></a></div><div class="next-post pull-right"><a href="/2018/08/13/thread/死磕Java并发/深入分析volatile的实现原理/"><span>【死磕Java并发】-----深入分析volatile的实现原理</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2018 By CAI TB</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.easing.1.3.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>