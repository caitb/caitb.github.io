<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="应用 2：应用 3：节衣缩食 —— 位图"><meta name="keywords" content="转发,Redis"><meta name="author" content="CAI TB,undefined"><meta name="copyright" content="CAI TB"><title>应用 2：应用 3：节衣缩食 —— 位图 | CAITBのBlog</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="/css/vue.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="sidebar" id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-nav sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本使用"><span class="toc-number">1.</span> <span class="toc-text">基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#零存零取"><span class="toc-number">1.0.1.</span> <span class="toc-text">零存零取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#整存零取"><span class="toc-number">1.0.2.</span> <span class="toc-text">整存零取</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#统计和查找"><span class="toc-number">2.</span> <span class="toc-text">统计和查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#魔术指令-bitfield"><span class="toc-number">3.</span> <span class="toc-text">魔术指令 bitfield</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#饱和截断-SAT"><span class="toc-number">3.0.1.</span> <span class="toc-text">饱和截断 SAT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#失败不执行-FAIL"><span class="toc-number">3.0.2.</span> <span class="toc-text">失败不执行 FAIL</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#思考-amp-作业"><span class="toc-number"></span> <span class="toc-text">思考 &amp; 作业</span></a></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvak7x33btj30500500ui.jpg"></div><div class="author-info__name text-center">CAI TB</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">27</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><div class="content" id="content-outer"><div id="top-container" style="background-image: url(https://ws1.sinaimg.cn/large/006tNbRwgy1fvak4ulv7nj31hc0xc0yl.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">CAITBのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">应用 2：应用 3：节衣缩食 —— 位图</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-25</time></div></div></div><div class="layout" id="content-inner"><article class="markdown-section" id="post"><div class="article-container" id="post-content"><blockquote>
<p><span style="color:rgb(61, 170, 214)">作者：</span>掘金小册</p>
<p><span style="color:rgb(61, 170, 214)">来源：</span><a href="https://juejin.im/books" target="_blank" rel="noopener">https://juejin.im/books</a></p>
</blockquote>
<p>在我们平时开发过程中，会有一些 bool 型数据需要存取，比如用户一年的签到记录，签了是 1，没签是 0，要记录 365 天。如果使用普通的 key/value，每个用户要记录 365 个，当用户上亿的时候，需要的存储空间是惊人的。</p>
<p>为了解决这个问题，Redis 提供了位图数据结构，这样每天的签到记录只占据一个位，365 天就是 365 个位，46 个字节 (一个稍长一点的字符串) 就可以完全容纳下，这就大大节约了存储空间。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/2/1645926f4520d0ce?imageslim" alt="img"></p>
<p>位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组。我们可以使用普通的 get/set 直接获取和设置整个位图的内容，也可以使用位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理。</p>
<p>以老钱的经验，在面试中有 Redis 位图使用经验的同学很少，如果你对 Redis 的位图有所了解，它将会是你的面试加分项。</p>
<p>&nbsp;</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Redis 的位数组是自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。</p>
<p>接下来我们使用位操作将字符串设置为 hello (不是直接使用 set 指令)，首先我们需要得到 hello 的 ASCII 码，用 Python 命令行可以很方便地得到每个字符的 ASCII 码的二进制值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bin(ord(<span class="string">'h'</span>))</span><br><span class="line"><span class="string">'0b1101000'</span>   <span class="comment"># 高位 -&gt; 低位</span></span><br><span class="line">&gt;&gt;&gt; bin(ord(<span class="string">'e'</span>))</span><br><span class="line"><span class="string">'0b1100101'</span></span><br><span class="line">&gt;&gt;&gt; bin(ord(<span class="string">'l'</span>))</span><br><span class="line"><span class="string">'0b1101100'</span></span><br><span class="line">&gt;&gt;&gt; bin(ord(<span class="string">'l'</span>))</span><br><span class="line"><span class="string">'0b1101100'</span></span><br><span class="line">&gt;&gt;&gt; bin(ord(<span class="string">'o'</span>))</span><br><span class="line"><span class="string">'0b1101111'</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/2/16459860644097de?imageslim" alt="img"></p>
<p>接下来我们使用 redis-cli 设置第一个字符，也就是位数组的前 8 位，我们只需要设置值为 1 的位，如上图所示，h 字符只有 1/2/4 位需要设置，e 字符只有 9/10/13/15 位需要设置。值得注意的是位数组的顺序和字符的位顺序是相反的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit s 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 9 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 10 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 13 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 15 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get s</span><br><span class="line"><span class="string">"he"</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子可以理解为「零存整取」，同样我们还也可以「零存零取」，「整存零取」。「零存」就是使用 setbit 对位值进行逐个设置，「整存」就是使用字符串一次性填充所有位数组，覆盖掉旧值。</p>
<h5 id="零存零取"><a href="#零存零取" class="headerlink" title="零存零取"></a>零存零取</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit w 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit w 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit w 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit w 1  <span class="comment"># 获取某个具体位置的值 0/1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit w 2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit w 4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit w 5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
<h5 id="整存零取"><a href="#整存零取" class="headerlink" title="整存零取"></a>整存零取</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w h  <span class="comment"># 整存</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit w 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit w 2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit w 4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit w 5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
<p>如果对应位的字节是不可打印字符，redis-cli 会显示该字符的 16 进制形式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit x 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit x 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get x</span><br><span class="line"><span class="string">"\xc0"</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h3 id="统计和查找"><a href="#统计和查找" class="headerlink" title="统计和查找"></a>统计和查找</h3><p>Redis 提供了位图统计指令 bitcount 和位图查找指令 bitpos，bitcount 用来统计指定位置范围内 1 的个数，bitpos 用来查找指定范围内出现的第一个 0 或 1。</p>
<p>比如我们可以通过 bitcount 统计用户一共签到了多少天，通过 bitpos 指令查找用户从哪一天开始第一次签到。如果指定了范围参数[start, end]，就可以统计在某个时间范围内用户签到了多少天，用户自某天以后的哪天开始签到。</p>
<p>遗憾的是， start 和 end 参数是字节索引，也就是说指定的位范围必须是 8 的倍数，而不能任意指定。这很奇怪，我表示不是很能理解 Antirez 为什么要这样设计。因为这个设计，我们无法直接计算某个月内用户签到了多少天，而必须要将这个月所覆盖的字节内容全部取出来 (getrange 可以取出字符串的子串) 然后在内存里进行统计，这个非常繁琐。</p>
<p>接下来我们简单试用一下 bitcount 指令和 bitpos 指令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitcount w</span><br><span class="line">(<span class="built_in">integer</span>) 21</span><br><span class="line">127.0.0.1:6379&gt; bitcount w 0 0  <span class="comment"># 第一个字符中 1 的位数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; bitcount w 0 1  <span class="comment"># 前两个字符中 1 的位数</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; bitpos w 0  <span class="comment"># 第一个 0 位</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; bitpos w 1  <span class="comment"># 第一个 1 位</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; bitpos w 1 1 1  <span class="comment"># 从第二个字符算起，第一个 1 位</span></span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; bitpos w 1 2 2  <span class="comment"># 从第三个字符算起，第一个 1 位</span></span><br><span class="line">(<span class="built_in">integer</span>) 17</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h3 id="魔术指令-bitfield"><a href="#魔术指令-bitfield" class="headerlink" title="魔术指令 bitfield"></a>魔术指令 bitfield</h3><p>前文我们设置 (setbit) 和获取 (getbit) 指定位的值都是单个位的，如果要一次操作多个位，就必须使用管道来处理。</p>
<p>不过 Redis 的 3.2 版本以后新增了一个功能强大的指令，有了这条指令，不用管道也可以一次进行多个位的操作。</p>
<p>bitfield 有三个子指令，分别是 get/set/incrby，它们都可以对指定位片段进行读写，但是最多只能处理 64 个连续的位，如果超过 64 位，就得使用多个子指令，bitfield 可以一次执行多个子指令。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/2/1645987653a2b337?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>接下来我们对照着上面的图看个简单的例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get u4 0  <span class="comment"># 从第一个位开始取 4 个位，结果是无符号数 (u)</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get u3 2  <span class="comment"># 从第三个位开始取 3 个位，结果是无符号数 (u)</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get i4 0  <span class="comment"># 从第一个位开始取 4 个位，结果是有符号数 (i)</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get i3 2  <span class="comment"># 从第三个位开始取 3 个位，结果是有符号数 (i)</span></span><br><span class="line">1) (<span class="built_in">integer</span>) -3</span><br></pre></td></tr></table></figure>
<p>所谓有符号数是指获取的位数组中第一个位是符号位，剩下的才是值。如果第一位是 1，那就是负数。无符号数表示非负数，没有符号位，获取的位数组全部都是值。有符号数最多可以获取 64 位，无符号数只能获取 63 位 (因为 Redis 协议中的 integer 是有符号数，最大 64 位，不能传递 64 位无符号值)。如果超出位数限制，Redis 就会告诉你参数错误。</p>
<p>接下来我们一次执行多个子指令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitfield w get u4 0 get u3 2 get i4 0 get i3 2</span><br><span class="line">1) (<span class="built_in">integer</span>) 6</span><br><span class="line">2) (<span class="built_in">integer</span>) 5</span><br><span class="line">3) (<span class="built_in">integer</span>) 6</span><br><span class="line">4) (<span class="built_in">integer</span>) -3</span><br></pre></td></tr></table></figure>
<p>wow，很魔法有没有！</p>
<p>然后我们使用 set 子指令将第二个字符 e 改成 a，a 的 ASCII 码是 97。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitfield w <span class="built_in">set</span> u8 8 97  <span class="comment"># 从第 8 个位开始，将接下来的 8 个位用无符号数 97 替换</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 101</span><br><span class="line">127.0.0.1:6379&gt; get w</span><br><span class="line"><span class="string">"hallo"</span></span><br></pre></td></tr></table></figure>
<p>再看第三个子指令 incrby，它用来对指定范围的位进行自增操作。既然提到自增，就有可能出现溢出。如果增加了正数，会出现上溢，如果增加的是负数，就会出现下溢出。Redis 默认的处理是折返。如果出现了溢出，就将溢出的符号位丢掉。如果是 8 位无符号数 255，加 1 后就会溢出，会全部变零。如果是 8 位有符号数 127，加 1 后就会溢出变成 -128。</p>
<p>接下来我们实践一下这个子指令 incrby :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield w incrby u4 2 1  <span class="comment"># 从第三个位开始，对接下来的 4 位无符号数 +1</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; bitfield w incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379&gt; bitfield w incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; bitfield w incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 14</span><br><span class="line">127.0.0.1:6379&gt; bitfield w incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 15</span><br><span class="line">127.0.0.1:6379&gt; bitfield w incrby u4 2 1  <span class="comment"># 溢出折返了</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
<p>bitfield 指令提供了溢出策略子指令 overflow，用户可以选择溢出行为，默认是折返 (wrap)，还可以选择失败 (fail) 报错不执行，以及饱和截断 (sat)，超过了范围就停留在最大最小值。overflow 指令只影响接下来的第一条指令，这条指令执行完后溢出策略会变成默认值折返 (wrap)。</p>
<p>接下来我们分别试试这两个策略的行为</p>
<h5 id="饱和截断-SAT"><a href="#饱和截断-SAT" class="headerlink" title="饱和截断 SAT"></a>饱和截断 SAT</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow sat incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow sat incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow sat incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow sat incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 14</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow sat incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 15</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow sat incrby u4 2 1  <span class="comment"># 保持最大值</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 15</span><br></pre></td></tr></table></figure>
<h5 id="失败不执行-FAIL"><a href="#失败不执行-FAIL" class="headerlink" title="失败不执行 FAIL"></a>失败不执行 FAIL</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow fail incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow fail incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow fail incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow fail incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 14</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow fail incrby u4 2 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 15</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow fail incrby u4 2 1  <span class="comment"># 不执行</span></span><br><span class="line">1) (nil)</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ol>
<li>文中我们使用位操作设置了 he 两个字符，请读者将完整的 hello 单词中 5 个字符都使用位操作设置一下。</li>
<li>bitfield 可以同时混合执行多个 set/get/incrby 子指令，请读者尝试完成。</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CAI TB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://caitb.github.io/2018/09/25/Redis 深度历险/5应用 3：节衣缩食 —— 位图/">https://caitb.github.io/2018/09/25/Redis 深度历险/5应用 3：节衣缩食 —— 位图/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://caitb.github.io" target="_blank">CAITBのBlog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/转发/">转发</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/09/25/Redis 深度历险/6应用 4：四两拨千斤 —— HyperLogLog/"><i class="fa fa-chevron-left">  </i><span>应用 4：四两拨千斤 —— HyperLogLog</span></a></div><div class="next-post pull-right"><a href="/2018/09/24/如何在面试中介绍自己的项目经验/"><span>如何在面试中介绍自己的项目经验</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2018 By CAI TB</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.easing.1.3.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>